#!/usr/bin/env python3
"""
Apply profile script - updates .env file with plan configuration.
Only modifies operational settings, never touches API keys or secrets.
"""
import os
import sys
import argparse
import logging
from pathlib import Path

# Add src to path to import modules
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

from src.config.plan_loader import PlanLoader

def setup_logging(level: str = "INFO"):
    """Setup logging for the script."""
    logging.basicConfig(
        level=getattr(logging, level.upper(), logging.INFO),
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s"
    )

def load_existing_env(env_path: str) -> dict:
    """Load existing .env file into a dictionary."""
    env_vars = {}
    if os.path.exists(env_path):
        with open(env_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    env_vars[key] = value
    return env_vars

def write_env_file(env_path: str, env_vars: dict, dry_run: bool = False):
    """Write environment variables to .env file."""
    if dry_run:
        print(f"\n--- DRY RUN: Would write to {env_path} ---")
        for key, value in sorted(env_vars.items()):
            print(f"{key}={value}")
        print("--- END DRY RUN ---\n")
        return
    
    # Backup existing file
    if os.path.exists(env_path):
        backup_path = f"{env_path}.backup"
        os.rename(env_path, backup_path)
        print(f"Backed up existing .env to {backup_path}")
    
    with open(env_path, 'w') as f:
        f.write("# =========================\n")
        f.write("#   CRYPTO SCALPING BOT\n")
        f.write("#   Generated by apply_profile.py\n")
        f.write("# =========================\n\n")
        
        # Write non-secret variables in logical groups
        for key, value in sorted(env_vars.items()):
            f.write(f"{key}={value}\n")
    
    print(f"Updated {env_path} with plan configuration")

def update_env_from_plan(plan: 'TradingPlan', existing_env: dict) -> dict:
    """Update environment variables based on plan, preserving secrets."""
    updated_env = existing_env.copy()
    
    # Determine MODE based on plan.mode
    if plan.mode == "paper":
        updated_env["MODE"] = "paper"
    elif plan.mode in ["live_testnet", "live_mainnet"]:
        updated_env["MODE"] = "live"
    else:
        updated_env["MODE"] = "paper"  # Safe fallback
    
    # Set BINANCE_TESTNET based on plan.mode
    if plan.mode == "live_testnet":
        updated_env["BINANCE_TESTNET"] = "true"
    elif plan.mode == "live_mainnet":
        updated_env["BINANCE_TESTNET"] = "false"
    # For paper mode, we don't change BINANCE_TESTNET
    
    # Operational settings from plan.risk
    updated_env["LEVERAGE"] = str(plan.risk.leverage)
    updated_env["MARGIN_MODE"] = plan.risk.margin_mode
    updated_env["POSITION_SIZE_PERCENT"] = str(plan.risk.position_size_pct)
    
    # Universe settings
    updated_env["TIMEFRAME"] = plan.universe.timeframe
    updated_env["MAX_SYMBOLS"] = str(plan.universe.dynamic_selector.max_symbols)
    
    # Risk settings
    updated_env["MAX_DAILY_LOSS_USD"] = str(plan.risk.max_daily_loss_pct * 20)  # Assuming 2000 USDT base
    
    # Never modify these secret keys
    secret_keys = [
        "BINANCE_API_KEY", "BINANCE_API_SECRET", 
        "TELEGRAM_TOKEN", "TELEGRAM_CHAT_ID"
    ]
    
    return updated_env

def check_missing_secrets(env_vars: dict, plan_mode: str) -> list:
    """Check for missing required secrets based on plan mode."""
    missing = []
    
    if plan_mode in ["live_testnet", "live_mainnet"]:
        if not env_vars.get("BINANCE_API_KEY"):
            missing.append("BINANCE_API_KEY")
        if not env_vars.get("BINANCE_API_SECRET"):
            missing.append("BINANCE_API_SECRET")
    
    # Telegram is optional but recommended
    telegram_missing = []
    if not env_vars.get("TELEGRAM_TOKEN"):
        telegram_missing.append("TELEGRAM_TOKEN")
    if not env_vars.get("TELEGRAM_CHAT_ID"):
        telegram_missing.append("TELEGRAM_CHAT_ID")
    
    return missing, telegram_missing

def main():
    parser = argparse.ArgumentParser(
        description="Apply trading plan configuration to .env file"
    )
    parser.add_argument(
        "--plan", "-p", 
        default="config/plan.yml",
        help="Path to plan YAML file (default: config/plan.yml)"
    )
    parser.add_argument(
        "--env", "-e",
        default=".env",
        help="Path to .env file (default: .env)"
    )
    parser.add_argument(
        "--dry-run", "-n",
        action="store_true",
        help="Show what would be changed without writing"
    )
    parser.add_argument(
        "--write", "-w",
        action="store_true",
        help="Actually write changes to .env file"
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Enable verbose logging"
    )
    
    args = parser.parse_args()
    
    # Setup logging
    setup_logging("DEBUG" if args.verbose else "INFO")
    log = logging.getLogger(__name__)
    
    # Require explicit --write or --dry-run
    if not args.write and not args.dry_run:
        print("ERROR: Must specify either --write or --dry-run")
        print("Use --dry-run to preview changes, --write to apply them")
        return 1
    
    try:
        # Load plan
        plan_loader = PlanLoader(args.plan)
        plan = plan_loader.load_plan()
        log.info(f"Loaded plan '{plan.profile_name}' with mode '{plan.mode}'")
        
        # Load existing .env
        existing_env = load_existing_env(args.env)
        log.info(f"Loaded {len(existing_env)} variables from {args.env}")
        
        # Update environment variables
        updated_env = update_env_from_plan(plan, existing_env)
        
        # Check for missing secrets
        missing_secrets, missing_telegram = check_missing_secrets(updated_env, plan.mode)
        
        if missing_secrets:
            print(f"\n‚ö†Ô∏è  WARNING: Missing required secrets for {plan.mode} mode:")
            for secret in missing_secrets:
                print(f"   - {secret}")
            print("   Bot will fall back to paper mode at runtime.")
            print("   Add these to your .env file manually.\n")
        
        if missing_telegram:
            print(f"\nüí° INFO: Optional Telegram settings not configured:")
            for secret in missing_telegram:
                print(f"   - {secret}")
            print("   Telegram notifications will be disabled.\n")
        
        # Show changes
        changes = []
        for key, new_value in updated_env.items():
            old_value = existing_env.get(key)
            if old_value != new_value:
                changes.append((key, old_value, new_value))
        
        if changes:
            print(f"\nChanges to apply ({len(changes)} variables):")
            for key, old_value, new_value in changes:
                print(f"  {key}: {old_value or '<not set>'} ‚Üí {new_value}")
        else:
            print("\nNo changes needed - .env already matches plan configuration")
        
        # Write file
        write_env_file(args.env, updated_env, dry_run=args.dry_run)
        
        if not args.dry_run and args.write:
            print(f"\n‚úÖ Applied plan '{plan.profile_name}' to {args.env}")
            print("\nNext steps:")
            print("  1. Review the generated .env file")
            print("  2. Add any missing API keys/secrets manually")
            print("  3. Run: python validate_config.py")
            print("  4. Run: python -m src.main")
        
        return 0
        
    except Exception as e:
        log.error(f"Error applying profile: {e}")
        return 1

if __name__ == "__main__":
    sys.exit(main())